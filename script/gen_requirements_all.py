#!/usr/bin/env python3
"""
Generate updated constraint and requirements files for Home Assistant Core.

This script scans integration manifests, gathers requirements, applies exclusions,
and generates the final constraint and requirements files used in CI and builds.

Usage:
    python3 -m script.gen_requirements_all
    python3 -m script.gen_requirements_all validate
    python3 -m script.gen_requirements_all ci
"""

from __future__ import annotations

import difflib
import importlib
import pkgutil
import re
import sys
import tomllib
from operator import itemgetter
from pathlib import Path
from typing import Any

from homeassistant.util.yaml.loader import load_yaml
from script.hassfest.model import Config, Integration

# -----------------------------
# Configuration Constants
# -----------------------------

EXCLUDED_REQUIREMENTS_ALL = {
    "atenpdu", "avea", "avion", "beacontools", "beewi-smartclim", "bluepy",
    "decora", "evdev", "face-recognition", "pybluez", "pycocotools", "pycups",
    "python-gammu", "python-lirc", "pyuserinput", "tensorflow", "tf-models-official",
}

INCLUDED_REQUIREMENTS_WHEELS = {
    "evdev", "pycups", "python-gammu", "pyuserinput",
}

OVERRIDDEN_REQUIREMENTS_ACTIONS = {
    "pytest": {"exclude": set(), "include": {"python-gammu"}, "markers": {}},
    "wheels_aarch64": {"exclude": set(), "include": INCLUDED_REQUIREMENTS_WHEELS, "markers": {}},
    "wheels_armhf": {
        "exclude": {"env-canada", "noaa-coops", "pyezviz", "pykrakenapi"},
        "include": INCLUDED_REQUIREMENTS_WHEELS,
        "markers": {},
    },
    "wheels_armv7": {"exclude": set(), "include": INCLUDED_REQUIREMENTS_WHEELS, "markers": {}},
    "wheels_amd64": {"exclude": set(), "include": INCLUDED_REQUIREMENTS_WHEELS, "markers": {}},
    "wheels_i386": {"exclude": set(), "include": INCLUDED_REQUIREMENTS_WHEELS, "markers": {}},
}

URL_PIN = (
    "https://developers.home-assistant.io/docs/"
    "creating_platform_code_review.html#1-requirements"
)

GENERATED_MESSAGE = "# Automatically generated by gen_requirements_all.py, do not edit\n\n"
PACKAGE_REGEX = re.compile(r"^(?:--.+\s)?([-_\.\w\d]+).*==.+$")

# -----------------------------
# Helper Functions
# -----------------------------

def _read_file(path: Path) -> str:
    """Safely read a UTF-8 text file."""
    return path.read_text(encoding="utf-8") if path.exists() else ""


def _write_file(path: Path, content: str) -> None:
    """Safely write UTF-8 text file."""
    path.write_text(content, encoding="utf-8")


def _normalize_package_name(package_name: str) -> str:
    """Normalize a package name for comparison."""
    return package_name.lower().replace("_", "-").replace(".", "-")


def normalize_package_name(requirement: str) -> str:
    """Extract normalized package name from a requirement string."""
    match = PACKAGE_REGEX.search(requirement)
    return _normalize_package_name(match.group(1)) if match else ""


def comment_requirement(req: str) -> bool:
    """Return True if requirement should be commented out."""
    return normalize_package_name(req) in EXCLUDED_REQUIREMENTS_ALL


def has_tests(module: str) -> bool:
    """Check if a module has corresponding test directory."""
    test_path = Path(module.replace(".", "/").replace("homeassistant", "tests", 1)) / "__init__.py"
    return test_path.exists()


def explore_module(package: str, recursive: bool) -> list[str]:
    """Recursively explore a Python package and return submodules."""
    found: list[str] = []
    try:
        module = importlib.import_module(package)
    except ImportError:
        return found

    if hasattr(module, "__path__"):
        for _, name, _ in pkgutil.iter_modules(module.__path__, f"{package}."):
            found.append(name)
            if recursive:
                found.extend(explore_module(name, False))
    return found


def core_requirements() -> list[str]:
    """Extract base dependencies from pyproject.toml."""
    data = tomllib.loads(Path("pyproject.toml").read_text(encoding="utf-8"))
    return data["project"]["dependencies"]


def process_requirements(
    errors: list[str],
    module_requirements: list[str],
    package: str,
    reqs: dict[str, list[str]],
) -> None:
    """Process module-level requirements and detect issues."""
    for req in module_requirements:
        if "://" in req:
            errors.append(f"{package}[Only PyPI dependencies are allowed: {req}]")
        if "==" not in req:
            errors.append(f"{package}[Please pin requirement {req}, see {URL_PIN}]")
        reqs.setdefault(req, []).append(package)


def gather_requirements_from_manifests(errors: list[str], reqs: dict[str, list[str]]) -> None:
    """Gather all integration manifest requirements."""
    config = _get_hassfest_config()
    for domain, integration in sorted(Integration.load_dir(config.core_integrations_path, config).items()):
        if not integration.disabled:
            process_requirements(errors, integration.requirements, f"homeassistant.components.{domain}", reqs)


def gather_requirements_from_modules(errors: list[str], reqs: dict[str, list[str]]) -> None:
    """Gather all requirements from modules."""
    packages = explore_module("homeassistant.scripts", True) + explore_module("homeassistant.auth", True)
    for package in sorted(packages):
        try:
            module = importlib.import_module(package)
            if getattr(module, "REQUIREMENTS", None):
                process_requirements(errors, module.REQUIREMENTS, package, reqs)
        except ImportError as err:
            print(f"‚ö†Ô∏è Import error in {package}: {err}")
            errors.append(package)


def diff_file(filename: str, content: str) -> list[str]:
    """Return diff between file and generated content."""
    return list(
        difflib.context_diff(
            [f"{line}\n" for line in _read_file(Path(filename)).split("\n")],
            [f"{line}\n" for line in content.split("\n")],
            filename,
            "generated",
        )
    )


def _get_hassfest_config() -> Config:
    """Return hassfest Config instance."""
    return Config(root=Path().absolute(), specific_integrations=None, action="validate", requirements=True)


# -----------------------------
# Main Entry Point
# -----------------------------

def main(validate: bool, ci: bool) -> int:
    """Main entry point for generating or validating requirements."""
    if not Path("requirements_all.txt").is_file():
        print("‚ùå Run this script from the Home Assistant root directory.")
        return 1

    print("üîç Gathering module data...")
    data = gather_modules()
    if data is None:
        return 1

    print("‚öôÔ∏è Generating requirements files...")
    reqs_file = requirements_output()
    reqs_all_file = requirements_all_output(data)
    reqs_test_all_file = requirements_test_all_output(data)
    reqs_pre_commit_file = requirements_pre_commit_output()
    constraints = gather_constraints()

    reqs_all_action_files = {
        action: requirements_all_action_output(data, action)
        for action in OVERRIDDEN_REQUIREMENTS_ACTIONS
    }

    files = [
        ("requirements.txt", reqs_file),
        ("requirements_all.txt", reqs_all_file),
        ("requirements_test_pre_commit.txt", reqs_pre_commit_file),
        ("requirements_test_all.txt", reqs_test_all_file),
        ("homeassistant/package_constraints.txt", constraints),
    ]

    if ci:
        files += [(f"requirements_all_{action}.txt", content) for action, content in reqs_all_action_files.items()]

    if validate:
        print("üß© Validating files...")
        differences = []
        for filename, content in files:
            diff = diff_file(filename, content)
            if diff:
                differences.append("".join(diff))
        if differences:
            print("‚ùå Differences detected! Please run `python3 -m script.gen_requirements_all` to update.")
            print("\n\n".join(differences))
            return 1
        print("‚úÖ Validation successful. No differences found.")
        return 0

    for filename, content in files:
        _write_file(Path(filename), content)

    print("‚úÖ Files successfully generated.")
    return 0


if __name__ == "__main__":
    validate_flag = sys.argv[-1] == "validate"
    ci_flag = sys.argv[-1] == "ci"
    sys.exit(main(validate_flag, ci_flag))
