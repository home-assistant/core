# Architectural Decision Record (ADR) 002

# Context
When we started implementing FR001 (displaying predefined categories) and FR002 (creating new categories), we had to decide how to structure both items and categories in the .shopping\_list.json file. This required extending the existing storage structure and the related functionality in the integrationâ€™s \_\_init\_\_.py file. Originally, the storage was just a simple dictionary of items without any category information, so we needed to design a new structure to support categories.

# Decision Drivers
- Minimize changes to the existing codebase
- Fast implementation within project timeline
- Simple data structure for easy maintenance
- Support for both predefined and user-created

# Considered Options
- Nest items directly inside category objects
- Use a flat structure with items referencing categories by string name (chosen)

# Decision
The team decided to implement a flat JSON structure where:
- Categories are stored as a simple string array
- Items reference their category by name (string)
- Each item contains: name, id, complete status, category, quantity, and unit.

This approach keeps the data model straightforward and avoids the complexity of managing category IDs or nested structures.

# Consequences

# Positive
- Fast to implement and integrate with existing code
- Easy to understand and maintain
- Minimal modifications to existing shopping list logic
- Categories can be added or removed with simple array operations

# Negative
- Category names must be unique (no ID-based lookups)
- Renaming categories requires updating all related items
- Less flexible for future features like category metadata or hierarchies